// Generated by Apple Swift version 4.0 effective-3.2 (swiftlang-900.0.65 clang-900.0.37)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_attribute(external_source_symbol)
# define SWIFT_STRINGIFY(str) #str
# define SWIFT_MODULE_NAMESPACE_PUSH(module_name) _Pragma(SWIFT_STRINGIFY(clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in=module_name, generated_declaration))), apply_to=any(function, enum, objc_interface, objc_category, objc_protocol))))
# define SWIFT_MODULE_NAMESPACE_POP _Pragma("clang attribute pop")
#else
# define SWIFT_MODULE_NAMESPACE_PUSH(module_name)
# define SWIFT_MODULE_NAMESPACE_POP
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR __attribute__((enum_extensibility(open)))
# else
#  define SWIFT_ENUM_ATTR
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import ObjectiveC;
@import Foundation;
@import CoreLocation;
@import Dispatch;
@import UIKit;
@import CoreData;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

SWIFT_MODULE_NAMESPACE_PUSH("MobileMessaging")
enum MessageDirection : int16_t;

SWIFT_CLASS("_TtC15MobileMessaging11BaseMessage")
@interface BaseMessage : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull messageId;
@property (nonatomic, readonly) enum MessageDirection direction;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull originalPayload;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqualWithObject:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class NSError;

/// The subclass of <code>NSOperation</code> from which all other operations should be derived.
/// This class adds both Conditions and Observers, which allow the operation to define
/// extended readiness requirements, as well as notify many interested parties
/// about interesting operation state changes
SWIFT_CLASS("_TtC15MobileMessaging9Operation")
@interface Operation : NSOperation
@property (nonatomic, copy) void (^ _Nullable completionBlock)(void);
@property (nonatomic, readonly, getter=isReady) BOOL ready;
@property (nonatomic) BOOL userInitiated;
@property (nonatomic, readonly, getter=isExecuting) BOOL executing;
@property (nonatomic, readonly, getter=isFinished) BOOL finished;
@property (nonatomic, readonly, getter=isCancelled) BOOL cancelled;
- (void)addDependency:(NSOperation * _Nonnull)operation;
- (void)start;
- (void)main;
/// <code>execute()</code> is the entry point of execution for all <code>Operation</code> subclasses.
/// If you subclass <code>Operation</code> and wish to customize its execution, you would
/// do so by overriding the <code>execute()</code> method.
/// At some point, your <code>Operation</code> subclass must call one of the “finish”
/// methods defined below; this is how you indicate that your operation has
/// finished its execution, and that operations dependent on yours can re-evaluate
/// their readiness state.
- (void)execute;
@property (nonatomic, readonly, copy) NSArray<NSError *> * _Nonnull errors;
- (void)cancel;
- (void)cancelWithErrors:(NSArray<NSError *> * _Nonnull)errors;
- (void)cancelWithError:(NSError * _Nonnull)error;
- (void)produceOperation:(NSOperation * _Nonnull)operation;
/// Most operations may finish with a single error, if they have one at all.
/// This is a convenience method to simplify calling the actual <code>finish()</code>
/// method. This is also useful if you wish to finish with an error provided
/// by the system frameworks. As an example, see <code>DownloadEarthquakesOperation</code>
/// for how an error from an <code>NSURLSession</code> is passed along via the
/// <code>finishWithError()</code> method.
- (void)finishWithError:(NSError * _Nullable)error;
- (void)finish:(NSArray<NSError *> * _Nonnull)errors;
/// Subclasses may override <code>finished(_:)</code> if they wish to react to the operation
/// finishing with errors. For example, the <code>LoadModelOperation</code> implements
/// this method to potentially inform the user about an error when trying to
/// bring up the Core Data stack.
- (void)finished:(NSArray<NSError *> * _Nonnull)errors;
- (void)waitUntilFinished;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A sublcass of <code>Operation</code> to execute a closure.
SWIFT_CLASS("_TtC15MobileMessaging14BlockOperation")
@interface BlockOperation : Operation
/// The designated initializer.
/// \param block The closure to run when the operation executes. This
/// closure will be run on an arbitrary queue. The parameter passed to the
/// block <em>MUST</em> be invoked by your code, or else the <code>BlockOperation</code>
/// will never finish executing. If this parameter is <code>nil</code>, the operation
/// will immediately finish.
///
- (nonnull instancetype)initWithBlock:(void (^ _Nullable)(void (^ _Nonnull)(void)))block OBJC_DESIGNATED_INITIALIZER;
/// A convenience initializer to execute a block on the main queue.
/// \param mainQueueBlock The block to execute on the main queue. Note
/// that this block does not have a “continuation” block to execute (unlike
/// the designated initializer). The operation will be automatically ended
/// after the <code>mainQueueBlock</code> is executed.
///
- (nonnull instancetype)initWithMainQueueBlock:(void (^ _Nonnull)(void))mainQueueBlock;
- (void)execute;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

typedef SWIFT_ENUM(int16_t, CampaignState) {
  CampaignStateActive = 0,
  CampaignStateSuspended = 1,
  CampaignStateFinished = 2,
};


SWIFT_PROTOCOL("_TtP15MobileMessaging27CustomPayloadSupportedTypes_")
@protocol CustomPayloadSupportedTypes
@end

@class NSDate;
@class NSNumber;
@class NSNull;

SWIFT_CLASS("_TtC15MobileMessaging19CustomUserDataValue")
@interface CustomUserDataValue : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable string;
@property (nonatomic, readonly, strong) NSDate * _Nullable date;
@property (nonatomic, readonly, strong) NSNumber * _Nullable number;
- (nonnull instancetype)initWithIntegerLiteral:(NSInteger)value;
- (nonnull instancetype)initWithFloatLiteral:(double)value;
- (nonnull instancetype)initWithStringLiteral:(NSString * _Nonnull)value;
- (nonnull instancetype)initWithExtendedGraphemeClusterLiteral:(NSString * _Nonnull)value;
- (nonnull instancetype)initWithUnicodeScalarLiteral:(NSString * _Nonnull)value;
- (nonnull instancetype)initWithDate:(NSDate * _Nonnull)date OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithInteger:(NSInteger)integer OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithDouble:(double)double_ OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithString:(NSString * _Nonnull)string OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNull:(NSNull * _Nonnull)null OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class DeliveryTimeInterval;

SWIFT_CLASS("_TtC15MobileMessaging12DeliveryTime")
@interface DeliveryTime : NSObject
@property (nonatomic, readonly, strong) DeliveryTimeInterval * _Nullable timeInterval;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging20DeliveryTimeInterval")
@interface DeliveryTimeInterval : NSObject
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class MMRegion;

SWIFT_PROTOCOL("_TtP15MobileMessaging16GeoEventHandling_")
@protocol GeoEventHandling
/// This callback is triggered after the geo event occurs. Default behaviour is implemented by <code>MMDefaultGeoEventHandling</code> class.
- (void)didEnterWithRegion:(MMRegion * _Nonnull)region;
@end

/// Describes the capability status for Geofencing Service. Possible values:
/// <ul>
///   <li>
///     <code>notDetermined</code>: The capability has not been requested yet
///   </li>
///   <li>
///     <code>authorized</code>: The capability has been requested and approved
///   </li>
///   <li>
///     <code>denied</code>: The capability has been requested but was denied by the user
///   </li>
///   <li>
///     <code>notAvailable</code>: The capability is not available (perhaps due to restrictions, or lack of support)
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, GeofencingCapabilityStatus) {
  GeofencingCapabilityStatusNotDetermined = 0,
  GeofencingCapabilityStatusAuthorized = 1,
  GeofencingCapabilityStatusDenied = 2,
  GeofencingCapabilityStatusNotAvailable = 3,
};

@class CLLocation;
enum LocationServiceUsage : NSInteger;
@class MMGeoMessage;

SWIFT_CLASS("_TtC15MobileMessaging17GeofencingService")
@interface GeofencingService : NSObject
- (void)syncWithServer:(void (^ _Nullable)(NSError * _Nullable))completion;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isGeofencingServiceEnabled;)
+ (BOOL)isGeofencingServiceEnabled SWIFT_WARN_UNUSED_RESULT;
/// Returns current user location with accuracy <code>kCLLocationAccuracyHundredMeters</code>.
@property (nonatomic, readonly, strong) CLLocation * _Nullable currentUserLocation;
/// Returns all the regions available in the Geofencing Service storage.
@property (nonatomic, readonly, copy) NSArray<MMRegion *> * _Nonnull allRegions;
/// Returns current capability status for Geofencing Service. For more information see <code>MMCapabilityStatus</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) enum GeofencingCapabilityStatus currentCapabilityStatus;)
+ (enum GeofencingCapabilityStatus)currentCapabilityStatus SWIFT_WARN_UNUSED_RESULT;
/// Requests permission to use location services whenever the app is running.
/// \param usage Defines the usage type for which permissions is requested.
///
/// \param completion A block that will be triggered once the authorization request is finished and the capability statys is defined. The current capability status is passed to the block as a parameter.
///
- (void)authorizeWithUsage:(enum LocationServiceUsage)usage completion:(void (^ _Nonnull)(enum GeofencingCapabilityStatus))completion;
/// Starts the Geofencing Service
/// During the startup process, the service automatically asks user to grant the appropriate permissions
/// Once the user granted the permissions, the service succesfully lauches.
/// \param completion A block that will be triggered once the startup process is finished. Contains a Bool flag parameter, that indicates whether the startup succeded.
///
- (void)start:(void (^ _Nullable)(BOOL))completion;
/// Stops the Geofencing Service
- (void)stop:(void (^ _Nullable)(BOOL))completion;
/// Accepts a geo message, which contains regions that should be monitored.
/// \param message A message object to add to the monitoring. Object of <code>MMGeoMessage</code> class.
///
- (void)addWithMessage:(MMGeoMessage * _Nonnull)message completion:(void (^ _Nullable)(void))completion;
/// Removes a message from the monitoring.
- (void)removeMessageWithId:(NSString * _Nonnull)messageId;
/// The geo event handling object defines the behaviour that is triggered during the geo event.
/// You can implement your own geo event handling either by subclassing <code>MMDefaultGeoEventHandling</code> or implementing the <code>GeoEventHandling</code> protocol.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <GeoEventHandling> _Nullable geoEventsHandler;)
+ (id <GeoEventHandling> _Nullable)geoEventsHandler SWIFT_WARN_UNUSED_RESULT;
+ (void)setGeoEventsHandler:(id <GeoEventHandling> _Nullable)value;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end



@class CLLocationManager;
@class CLRegion;

@interface GeofencingService (SWIFT_EXTENSION(MobileMessaging)) <CLLocationManagerDelegate>
- (void)locationManager:(CLLocationManager * _Nonnull)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didStartMonitoringForRegion:(CLRegion * _Nonnull)region;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didEnterRegion:(CLRegion * _Nonnull)region;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didFailWithError:(NSError * _Nonnull)error;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
@end




/// A subclass of <code>Operation</code> that executes zero or more operations as part of its
/// own execution. This class of operation is very useful for abstracting several
/// smaller operations into a larger operation. As an example, the <code>GetEarthquakesOperation</code>
/// is composed of both a <code>DownloadEarthquakesOperation</code> and a <code>ParseEarthquakesOperation</code>.
/// Additionally, <code>GroupOperation</code>s are useful if you establish a chain of dependencies,
/// but part of the chain may “loop”. For example, if you have an operation that
/// requires the user to be authenticated, you may consider putting the “login”
/// operation inside a group operation. That way, the “login” operation may produce
/// subsequent operations (still within the outer <code>GroupOperation</code>) that will all
/// be executed before the rest of the operations in the initial chain of operations.
SWIFT_CLASS("_TtC15MobileMessaging14GroupOperation")
@interface GroupOperation : Operation
- (nonnull instancetype)initWithOperations:(NSArray<NSOperation *> * _Nonnull)operations OBJC_DESIGNATED_INITIALIZER;
- (void)cancel;
- (void)execute;
- (void)addOperation:(NSOperation * _Nonnull)operation;
/// Note that some part of execution has produced an error.
/// Errors aggregated through this method will be included in the final array
/// of errors reported to observers and to the <code>finished(_:)</code> method.
- (void)aggregateError:(NSError * _Nonnull)error;
- (void)operationDidFinish:(NSOperation * _Nonnull)operation withErrors:(NSArray<NSError *> * _Nonnull)errors;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class OperationQueue;

/// The delegate of an <code>OperationQueue</code> can respond to <code>Operation</code> lifecycle
/// events by implementing these methods.
/// In general, implementing <code>OperationQueueDelegate</code> is not necessary; you would
/// want to use an <code>OperationObserver</code> instead. However, there are a couple of
/// situations where using <code>OperationQueueDelegate</code> can lead to simpler code.
/// For example, <code>GroupOperation</code> is the delegate of its own internal
/// <code>OperationQueue</code> and uses it to manage dependencies.
SWIFT_PROTOCOL("_TtP15MobileMessaging22OperationQueueDelegate_")
@protocol OperationQueueDelegate <NSObject>
@optional
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue willAddOperation:(NSOperation * _Nonnull)operation;
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue operationDidFinish:(NSOperation * _Nonnull)operation withErrors:(NSArray<NSError *> * _Nonnull)errors;
@end


@interface GroupOperation (SWIFT_EXTENSION(MobileMessaging)) <OperationQueueDelegate>
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue willAddOperation:(NSOperation * _Nonnull)operation;
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue operationDidFinish:(NSOperation * _Nonnull)operation withErrors:(NSArray<NSError *> * _Nonnull)errors;
@end


/// Describes the kind of location service. Possible values:
/// <ul>
///   <li>
///     Location Updates
///   </li>
///   <li>
///     Region Monitoring
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15MobileMessaging19LocationServiceKind")
@interface LocationServiceKind : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<LocationServiceKind *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(LocationServiceKind * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) LocationServiceKind * _Nonnull locationUpdates;)
+ (LocationServiceKind * _Nonnull)locationUpdates SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) LocationServiceKind * _Nonnull regionMonitoring;)
+ (LocationServiceKind * _Nonnull)regionMonitoring SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

/// Describes the usage type for the location service. Possible values:
/// <ul>
///   <li>
///     When in Use
///   </li>
///   <li>
///     Always
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, LocationServiceUsage) {
/// This app is authorized to start most location services while running in the foreground.
  LocationServiceUsageWhenInUse = 0,
/// This app is authorized to start location services at any time.
  LocationServiceUsageAlways = 1,
};

typedef SWIFT_ENUM(int8_t, MMDay) {
  MMDayMo = 1,
  MMDayTu = 2,
  MMDayWe = 3,
  MMDayTh = 4,
  MMDayFr = 5,
  MMDaySa = 6,
  MMDaySu = 7,
};

@class MOMessage;
@class MTMessage;
enum MMSeenStatus : int16_t;
enum MOMessageSentStatus : int16_t;

/// The protocol describes implementation of the Message Storage. The Message Storage persists all the messages (both mobile originated and mobile terminated).
SWIFT_PROTOCOL("_TtP15MobileMessaging14MessageStorage_")
@protocol MessageStorage
/// The queue in which all the hooks(inserts, updates) are dispatched.
/// The queue must be provided by the particular implementation of this protocol in order to provide thread safety and performance aspects.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull queue;
/// This method is called by the Mobile Messaging SDK during the initialization process. You implement your custom preparation routine here if needed.
- (void)start;
/// This method is called by the Mobile Messaging SDK while stopping the currently running session (see also <code>MobileMessaging.stop()</code> method). You implement your custom deinitialization routine here if needed.
- (void)stop;
/// This method is called whenever a new mobile originated message is about to be sent to the server.
- (void)insertWithOutgoing:(NSArray<MOMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever a new mobile terminated message (either push(remote) notifictaion or fetched message) is received by the Mobile Messaging SDK.
- (void)insertWithIncoming:(NSArray<MTMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
/// This method is used by the Mobile Messaging SDK in order to detect duplicated messages persisted in the Message Storage. It is strongly recommended to implement this method in your custom Message Storage.
/// \param messageId unique identifier of a MT message. Consider this identifier as a primary key.
///
- (BaseMessage * _Nullable)findMessageWithId:(NSString * _Nonnull)messageId SWIFT_WARN_UNUSED_RESULT;
/// This method is called whenever the seen status is updated for a particular mobile terminated (MT) message.
/// \param status actual seen status for a message
///
/// \param messageId unique identifier of a MT message
///
- (void)updateWithMessageSeenStatus:(enum MMSeenStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever the delivery report is updated for a particular mobile terminated (MT) message.
/// \param isDelivered boolean flag which defines whether the delivery report for a message was successfully sent
///
/// \param messageId unique identifier of a MT message
///
- (void)updateWithDeliveryReportStatus:(BOOL)isDelivered for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever the sending status is updated for a particular mobile originated (MO) message.
/// \param status actual sending status for a MO message
///
/// \param messageId unique identifier of a MO message
///
- (void)updateWithMessageSentStatus:(enum MOMessageSentStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
@end

@class Query;

SWIFT_PROTOCOL("_TtP15MobileMessaging22MessageStorageRemovers_")
@protocol MessageStorageRemovers
- (void)removeAllMessages;
- (void)removeWithIds:(NSArray<NSString *> * _Nonnull)messageIds;
- (void)removeWithQuery:(Query * _Nonnull)query;
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging21MessageStorageFinders_")
@protocol MessageStorageFinders
- (void)findAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)findMessagesWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)findMessagesWithQuery:(Query * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
@end

@protocol MessageStorageDelegate;

/// Default implementation of the Message Storage protocol. Uses Core Data persistent storage with SQLite database.
SWIFT_CLASS("_TtC15MobileMessaging23MMDefaultMessageStorage")
@interface MMDefaultMessageStorage : NSObject <MessageStorage, MessageStorageFinders, MessageStorageRemovers>
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull queue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
- (void)start;
- (void)stop;
- (void)insertWithOutgoing:(NSArray<MOMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
- (void)insertWithIncoming:(NSArray<MTMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
- (BaseMessage * _Nullable)findMessageWithId:(NSString * _Nonnull)messageId SWIFT_WARN_UNUSED_RESULT;
- (void)updateWithMessageSentStatus:(enum MOMessageSentStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
- (void)updateWithMessageSeenStatus:(enum MMSeenStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
- (void)updateWithDeliveryReportStatus:(BOOL)isDelivered for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
@property (nonatomic, weak) id <MessageStorageDelegate> _Nullable delegate;
@property (nonatomic, strong) dispatch_queue_t _Nonnull delegateQueue;
- (void)findAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)findMessagesWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)findMessagesWithQuery:(Query * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<BaseMessage *> * _Nullable))completion;
- (void)removeAllMessages;
- (void)removeWithIds:(NSArray<NSString *> * _Nonnull)messageIds;
- (void)removeWithQuery:(Query * _Nonnull)query;
@end

enum MessageDeliveryMethod : int16_t;

/// Incapsulates all the attributes related to the remote notifications.
SWIFT_CLASS("_TtC15MobileMessaging9MTMessage")
@interface MTMessage : BaseMessage
/// Defines the origin of a message.
/// Message may be either pushed by APNS, generated locally or pulled from the server.
@property (nonatomic, readonly) enum MessageDeliveryMethod deliveryMethod;
/// Defines if a message is silent. Silent messages have neither text nor sound attributes.
@property (nonatomic, readonly) BOOL isSilent;
/// Custom message payload.
/// See also: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Custom-message-payload">Custom message payload</a>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable customPayload;
/// Title of the message. If message title may be localized (“alert.title-loc-key” attribute is present and refers to an existing localized string), the localized string is returned, otherwise the value of “alert.title” attribute is returned if present.
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// Text of a message. If message may be localized (“alert.loc-key” attribute is present and refers to an existing localized string), the localized string is returned, otherwise the value of “alert.body” attribute is returned if present.
@property (nonatomic, readonly, copy) NSString * _Nullable text;
/// Localization key of the message title.
@property (nonatomic, readonly, copy) NSString * _Nullable title_loc_key;
/// Localization args of the message title.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable title_loc_args;
/// Localization key of the message text.
@property (nonatomic, readonly, copy) NSString * _Nullable loc_key;
/// Localization args of the message.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable loc_args;
/// Sound of the message.
@property (nonatomic, readonly, copy) NSString * _Nullable sound;
/// Interactive category Id
@property (nonatomic, readonly, copy) NSString * _Nullable category;
@property (nonatomic, readonly, copy) NSString * _Nullable contentUrl;
@property (nonatomic, readonly) NSTimeInterval sendDateTime;
@property (nonatomic) enum MMSeenStatus seenStatus;
@property (nonatomic, copy) NSDate * _Nullable seenDate;
@property (nonatomic) BOOL isDeliveryReportSent;
@property (nonatomic, copy) NSDate * _Nullable deliveryReportedDate;
/// Initializes the MTMessage from original payload.
- (nullable instancetype)initWithPayload:(NSDictionary * _Nonnull)payload OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging12MMGeoMessage")
@interface MMGeoMessage : MTMessage
@property (nonatomic, readonly, copy) NSString * _Nonnull campaignId;
@property (nonatomic, readonly, copy) NSSet<MMRegion *> * _Nonnull regions;
@property (nonatomic, readonly, copy) NSDate * _Nonnull startTime;
@property (nonatomic, readonly, copy) NSDate * _Nonnull expiryTime;
@property (nonatomic, readonly) BOOL isNotExpired;
@property (nonatomic) enum CampaignState campaignState;
- (nullable instancetype)initWithPayload:(NSDictionary * _Nonnull)payload OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) BOOL isNowAppropriateTimeForEntryNotification;
@property (nonatomic, readonly) BOOL isNowAppropriateTimeForExitNotification;
@end


SWIFT_CLASS("_TtC15MobileMessaging14MMInstallation")
@interface MMInstallation : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// A read-only opaque identifier assigned by APNs to a specific app on a specific device. Each app instance receives its unique token when it registers with APNs and must share this token with its provider.
@property (nonatomic, readonly, copy) NSString * _Nullable deviceToken;
/// Explicitly tries to sync the entire installation (registration data, system data, user data) with the server.
- (void)syncInstallationWithServerWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Explicitly tries to sync the system data with the server.
- (void)syncSystemDataWithServerWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// The number currently set as the badge of the app icon in Springboard.
/// Set to 0 (zero) to hide the badge number. The default value of this property is 0.
@property (nonatomic) NSInteger badgeNumber;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

typedef SWIFT_ENUM(NSUInteger, MMLogLevel) {
/// <ul>
///   <li>
///     No logs
///   </li>
/// </ul>
  MMLogLevelOff = 0,
/// <ul>
///   <li>
///     Error logs only
///   </li>
/// </ul>
  MMLogLevelError = 1,
/// <ul>
///   <li>
///     Error and warning logs
///   </li>
/// </ul>
  MMLogLevelWarning = 2,
/// <ul>
///   <li>
///     Error, warning and info logs
///   </li>
/// </ul>
  MMLogLevelInfo = 3,
/// <ul>
///   <li>
///     Error, warning, info and debug logs
///   </li>
/// </ul>
  MMLogLevelDebug = 4,
/// <ul>
///   <li>
///     Error, warning, info, debug and verbose logs
///   </li>
/// </ul>
  MMLogLevelVerbose = 5,
  MMLogLevelAll = 6,
};


SWIFT_CLASS("_TtC15MobileMessaging11MMLogOutput")
@interface MMLogOutput : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<MMLogOutput *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMLogOutput * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull None;)
+ (MMLogOutput * _Nonnull)None SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull Console;)
+ (MMLogOutput * _Nonnull)Console SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull ASL;)
+ (MMLogOutput * _Nonnull)ASL SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull File;)
+ (MMLogOutput * _Nonnull)File SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class UIViewController;

SWIFT_PROTOCOL("_TtP15MobileMessaging9MMLogging_")
@protocol MMLogging
@property (nonatomic, strong) MMLogOutput * _Nonnull logOutput;
@property (nonatomic) enum MMLogLevel logLevel;
@property (nonatomic, readonly, copy) NSString * _Nullable logFilePath;
- (void)sendLogsFromViewController:(UIViewController * _Nonnull)vc;
- (void)logDebugWithMessage:(NSString * _Nonnull)message;
- (void)logInfoWithMessage:(NSString * _Nonnull)message;
- (void)logErrorWithMessage:(NSString * _Nonnull)message;
- (void)logWarnWithMessage:(NSString * _Nonnull)message;
- (void)logVerboseWithMessage:(NSString * _Nonnull)message;
@end

@class CLCircularRegion;

SWIFT_CLASS("_TtC15MobileMessaging8MMRegion")
@interface MMRegion : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
@property (nonatomic, readonly) CLLocationCoordinate2D center;
@property (nonatomic, readonly) double radius;
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
@property (nonatomic, readonly, strong) CLCircularRegion * _Nonnull circularRegion;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
@property (nonatomic, readonly) NSInteger hashValue;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

typedef SWIFT_ENUM(int16_t, MMSeenStatus) {
  MMSeenStatusNotSeen = 0,
  MMSeenStatusSeenNotSent = 1,
  MMSeenStatusSeenSent = 2,
};

enum MMUserPredefinedDataKeys : NSInteger;

SWIFT_CLASS("_TtC15MobileMessaging6MMUser")
@interface MMUser : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Unique push registration identifier issued by server. This identifier matches one to one with APNS cloud token of the particular application installation. This identifier is only available after <code>MMNotificationRegistrationUpdated</code> event.
@property (nonatomic, readonly, copy) NSString * _Nullable pushRegistrationId;
/// The user’s id you can provide in order to link your own unique user identifier with Mobile Messaging user id, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable externalId;
/// Saves the External User Id on the server asynchronously and executes the given callback block.
/// \param externalId The id you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithExternalId:(NSString * _Nonnull)externalId completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// The user’s email address. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable email;
/// Saves the email on the server asynchronously and executes the given callback block.
/// \param email The email you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithEmail:(NSString * _Nonnull)email completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// A user’s MSISDN. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable msisdn;
/// Saves the MSISDN on the server asynchronously and executes the given callback block.
/// \param msisdn The MSISDN you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithMsisdn:(NSString * _Nonnull)msisdn completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Returns user’s custom data. Arbitrary attributes that are related to a particular user. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSDictionary<NSString *, CustomUserDataValue *> * _Nullable customData;
/// Saves the user’s custom data on the server asynchronously and executes the given callback block.
/// \param customData The dictionary representing data you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithCustomData:(NSDictionary<NSString *, CustomUserDataValue *> * _Nonnull)customData completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Returns the custom data value associated with a given key.
/// \param key The key for which to return the corresponding value.
///
- (CustomUserDataValue * _Nullable)customDataForKey:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Sets the custom data value for a given key. To save data, call <code>save(completion:)</code> method of <code>MMUser</code> object.
/// \param key The key for <code>object</code>.
///
/// \param object The object for <code>key</code>. Pass <code>object</code> as either <code>nil</code> or <code>NSNull()</code> in order to remove the key-value pair on the server.
///
- (void)setWithCustomData:(CustomUserDataValue * _Nullable)object forKey:(NSString * _Nonnull)key;
/// Sets the custom data value for a given key, immediately sends changes to the server asynchronously and executes the given callback block.
/// \param key The key for <code>object</code>.
///
/// \param object The object for <code>key</code>. Pass <code>object</code> as either <code>nil</code> or <code>NSNull()</code> in order to remove the key-value pair on the server.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithCustomData:(CustomUserDataValue * _Nullable)object forKey:(NSString * _Nonnull)key completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Returns user’s predefined attributes (all possible attributes are described in the <code>MMUserPredefinedDataKeys</code> enum). Predefined attributes that are related to a particular user. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSDictionary<NSString *, NSString *> * _Nullable predefinedData;
/// Saves the user’s attributes on the server asynchronously and executes the given callback block.
/// \param predefinedData The dictionary representing data you want to link with the current user.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithPredefinedData:(NSDictionary<NSString *, NSString *> * _Nonnull)predefinedData completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Returns the user’s attribute value associated with a given key.
/// \param key The key of type <code>MMUserPredefinedDataKeys</code> for which to return the corresponding value.
///
- (NSString * _Nullable)predefinedDataForKey:(enum MMUserPredefinedDataKeys)key SWIFT_WARN_UNUSED_RESULT;
/// Sets the user’s attribute value for a given key. To save data, call <code>save(completion:)</code> method of <code>MMUser</code> object.
/// \param key The key of type <code>MMUserPredefinedDataKeys</code> for <code>object</code>.
///
/// \param object The object for <code>key</code>. Pass <code>object</code> as either <code>nil</code> or <code>NSNull()</code> in order to remove the key-value pair on the server.
///
- (void)setWithPredefinedData:(NSString * _Nullable)object forKey:(enum MMUserPredefinedDataKeys)key;
/// Sets the user’s attribute value for a given key, immediately sends changes to the server asynchronously and executes the given callback block.
/// \param key The key for <code>object</code>.
///
/// \param object The object for <code>key</code> of type <code>MMUserPredefinedDataKeys</code>. Pass <code>object</code> as either <code>nil</code> or <code>NSNull()</code> in order to remove the key-value pair on the server.
///
/// \param completion The block to execute after the server responded.
///
- (void)saveWithPredefinedData:(NSString * _Nullable)object forKey:(enum MMUserPredefinedDataKeys)key completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Explicitly tries to save all user data on the server.
/// \param completion The block to execute after the server responded.
///
- (void)save:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Tries to fetch the user data from the server.
/// \param completion The block to execute after the server responded.
///
- (void)fetchFromServerWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

typedef SWIFT_ENUM(NSInteger, MMUserGenderValues) {
  MMUserGenderValuesFemale = 0,
  MMUserGenderValuesMale = 1,
};

typedef SWIFT_ENUM(NSInteger, MMUserPredefinedDataKeys) {
  MMUserPredefinedDataKeysMSISDN = 0,
  MMUserPredefinedDataKeysFirstName = 1,
  MMUserPredefinedDataKeysLastName = 2,
  MMUserPredefinedDataKeysMiddleName = 3,
  MMUserPredefinedDataKeysGender = 4,
  MMUserPredefinedDataKeysBirthdate = 5,
  MMUserPredefinedDataKeysEmail = 6,
  MMUserPredefinedDataKeysTelephone = 7,
};


SWIFT_CLASS("_TtC15MobileMessaging9MOMessage")
@interface MOMessage : BaseMessage
@property (nonatomic, readonly, copy) NSString * _Nullable destination;
@property (nonatomic, readonly, copy) NSString * _Nonnull text;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id <CustomPayloadSupportedTypes>> * _Nullable customPayload;
@property (nonatomic, readonly) enum MOMessageSentStatus sentStatus;
@property (nonatomic, readonly, copy) NSDate * _Nonnull composedDate;
@property (nonatomic, readonly, copy) NSString * _Nullable bulkId;
@property (nonatomic, readonly, copy) NSString * _Nullable initialMessageId;
- (nonnull instancetype)initWithDestination:(NSString * _Nullable)destination text:(NSString * _Nonnull)text customPayload:(NSDictionary<NSString *, id <CustomPayloadSupportedTypes>> * _Nullable)customPayload composedDate:(NSDate * _Nonnull)composedDate bulkId:(NSString * _Nullable)bulkId initialMessageId:(NSString * _Nullable)initialMessageId;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload SWIFT_UNAVAILABLE;
@end

typedef SWIFT_ENUM(int16_t, MOMessageSentStatus) {
  MOMessageSentStatusUndefined = -1,
  MOMessageSentStatusSentSuccessfully = 0,
  MOMessageSentStatusSentWithFailure = 1,
};






typedef SWIFT_ENUM(int16_t, MessageDeliveryMethod) {
  MessageDeliveryMethodUndefined = 0,
  MessageDeliveryMethodPush = 1,
  MessageDeliveryMethodPull = 2,
  MessageDeliveryMethodGeneratedLocally = 3,
};

typedef SWIFT_ENUM(int16_t, MessageDirection) {
  MessageDirectionMT = 0,
  MessageDirectionMO = 1,
};


SWIFT_PROTOCOL("_TtP15MobileMessaging15MessageHandling_")
@protocol MessageHandling
/// This callback is triggered after the new message is received. Default behaviour is implemented by <code>MMDefaultMessageHandling</code> class.
- (void)didReceiveNewMessageWithMessage:(MTMessage * _Nonnull)message completion:(void (^ _Nullable)(void))completion;
@end



SWIFT_PROTOCOL("_TtP15MobileMessaging22MessageStorageDelegate_")
@protocol MessageStorageDelegate
- (void)didInsertNewMessages:(NSArray<BaseMessage *> * _Nonnull)messages;
- (void)didUpdateMessage:(BaseMessage * _Nonnull)message;
- (void)didRemoveMessages:(NSArray<BaseMessage *> * _Nonnull)messages;
@end



@class UserNotificationType;
@class UILocalNotification;
@class UserAgent;
@class NSURLSessionConfiguration;
@class PrivacySettings;

SWIFT_CLASS("_TtC15MobileMessaging15MobileMessaging")
@interface MobileMessaging : NSObject
/// Fabric method for Mobile Messaging session.
/// \param code The application code of your Application from Push Portal website.
///
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(UserNotificationType * _Nonnull)notificationType SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// warning:
/// The cleanup (parameter <code>forceCleanup = true</code>) must be performed manually if you changed the application code while <code>PrivacySettings.applicationCodePersistingDisabled</code> is set to <code>true</code>.
/// \param code The application code of your Application from Push Portal website.
///
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
/// \param forceCleanup Defines whether the SDK must be cleaned up on startup.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(UserNotificationType * _Nonnull)notificationType forceCleanup:(BOOL)forceCleanup SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
/// \param code The application code of your Application from Push Portal website.
///
/// \param backendBaseURL Your backend server base URL, optional parameter. Default is http://oneapi.infobip.com.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(UserNotificationType * _Nonnull)notificationType backendBaseURL:(NSString * _Nonnull)backendBaseURL SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// It is possible to supply a default implementation of Message Storage to the Mobile Messaging library during initialization. In this case the library will save all received Push messages using the <code>MMDefaultMessageStorage</code>. Library can also be initialized either without message storage or with user-provided one (see <code>withMessageStorage(messageStorage:)</code>).
- (MobileMessaging * _Nonnull)withDefaultMessageStorage SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// It is possible to supply an implementation of Message Storage to the Mobile Messaging library during initialization. In this case the library will save all received Push messages to the supplied <code>messageStorage</code>. Library can also be initialized either without message storage or with the default message storage (see <code>withDefaultMessageStorage()</code> method).
/// \param messageStorage a storage object, that implements the <code>MessageStorage</code> protocol
///
- (MobileMessaging * _Nonnull)withMessageStorage:(id <MessageStorage> _Nonnull)messageStorage SWIFT_WARN_UNUSED_RESULT;
/// Starts a new Mobile Messaging session.
/// This method should be called form AppDelegate’s <code>application(_:didFinishLaunchingWithOptions:)</code> callback.
/// remark:
/// For now, Mobile Messaging SDK doesn’t support Badge. You should handle the badge counter by yourself.
- (void)start:(void (^ _Nullable)(void))completion;
/// Syncronizes all available subservices with the server.
+ (void)sync;
/// Current push registration status.
/// The status defines whether the device is allowed to be receiving push notifications (regular push messages/geofencing campaign messages/messages fetched from the server).
/// MobileMessaging SDK has the push registration enabled by default.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isPushRegistrationEnabled;)
+ (BOOL)isPushRegistrationEnabled SWIFT_WARN_UNUSED_RESULT;
/// Cleans up all internal persisted data.
/// Use this method in order to completely drop any data persisted by the SDK (i.e. internal SDK data, optional user data, optional messages metadata).
/// \param clearKeychain defines whether the internalId in keychain will be cleaned. True by default.
///
+ (void)cleanUpAndStop:(BOOL)clearKeychain;
/// Enables the push registration so the device can receive push notifications (regular push messages/geofencing campaign messages/messages fetched from the server).
/// MobileMessaging SDK has the push registration enabled by default.
+ (void)enablePushRegistrationWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Disables the push registration so the device no longer receives any push notifications (regular push messages/geofencing campaign messages/messages fetched from the server).
/// MobileMessaging SDK has the push registration enabled by default.
+ (void)disablePushRegistrationWithCompletion:(void (^ _Nullable)(NSError * _Nullable))completion;
/// Stops all the currently running Mobile Messaging services.
/// attention:
/// This function doesn’t disable push notifications, they are still being received by the OS.
/// \param cleanUpData defines whether the Mobile Messaging internal storage will be dropped. False by default.
///
+ (void)stop:(BOOL)cleanUpData;
/// Logging utility is used for:
/// <ul>
///   <li>
///     setting up the logging options and logging levels.
///   </li>
///   <li>
///     obtaining a path to the logs file in case the Logging utility is set up to log in file (logging options contains <code>.file</code> option).
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <MMLogging> _Nullable logger;)
+ (id <MMLogging> _Nullable)logger SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogger:(id <MMLogging> _Nullable)value;
/// This method handles a new APNs device token and updates user’s registration on the server.
/// This method should be called form AppDelegate’s <code>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</code> callback.
/// \param token A token that identifies a particular device to APNs.
///
+ (void)didRegisterForRemoteNotificationsWithDeviceToken:(NSData * _Nonnull)token;
/// This method handles incoming remote notifications and triggers sending procedure for delivery reports. The method should be called from AppDelegate’s <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> callback.
/// \param userInfo A dictionary that contains information related to the remote notification, potentially including a badge number for the app icon, an alert sound, an alert message to display to the user, a notification identifier, and custom data.
///
/// \param completionHandler A block to execute when the download operation is complete. The block is originally passed to AppDelegate’s <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> callback as a <code>fetchCompletionHandler</code> parameter. Mobile Messaging will execute this block after sending notification’s delivery report.
///
+ (void)didReceiveRemoteNotification:(NSDictionary * _Nonnull)userInfo fetchCompletionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))completionHandler;
/// This method is called when a running app receives a local notification. The method should be called from AppDelegate’s <code>application(_:didReceiveLocalNotification:)</code> or <code>application(_:didReceive:)</code> callback.
/// \param notification A local notification that encapsulates details about the notification, potentially including custom data.
///
+ (void)didReceiveLocalNotification:(UILocalNotification * _Nonnull)notification;
/// Maintains attributes related to the current application installation such as APNs device token, badge number, etc.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMInstallation * _Nullable currentInstallation;)
+ (MMInstallation * _Nullable)currentInstallation SWIFT_WARN_UNUSED_RESULT;
/// Returns the default message storage if used. For more information see <code>MMDefaultMessageStorage</code> class description.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMDefaultMessageStorage * _Nullable defaultMessageStorage;)
+ (MMDefaultMessageStorage * _Nullable)defaultMessageStorage SWIFT_WARN_UNUSED_RESULT;
/// Maintains attributes related to the current user such as unique ID for the registered user, email, MSISDN, custom data, external id.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUser * _Nullable currentUser;)
+ (MMUser * _Nullable)currentUser SWIFT_WARN_UNUSED_RESULT;
/// This method sets seen status for messages and sends a corresponding request to the server. If something went wrong, the library will repeat the request until it reaches the server.
/// \param messageIds Array of identifiers of messages that need to be marked as seen.
///
+ (void)setSeenWithMessageIds:(NSArray<NSString *> * _Nonnull)messageIds;
/// This method sends mobile originated messages to the server.
/// \param messages Array of objects of <code>MOMessage</code> class that need to be sent.
///
/// \param completion The block to execute after the server responded, passes an array of <code>MOMessage</code> messages, that cont
///
+ (void)sendMessages:(NSArray<MOMessage *> * _Nonnull)messages completion:(void (^ _Nullable)(NSArray<MOMessage *> * _Nullable, NSError * _Nullable))completion;
/// An auxillary component provides the convinient access to the user agent data.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserAgent * _Nonnull userAgent;)
+ (UserAgent * _Nonnull)userAgent SWIFT_WARN_UNUSED_RESULT;
/// A block object to be executed when user opens the app by tapping on the notification alert.
/// Default implementation marks the corresponding message as seen.
/// This block takes:
/// <ul>
///   <li>
///     single MTMessage object initialized from the Dictionary.
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) void (^ _Nullable notificationTapHandler)(MTMessage * _Nonnull);)
+ (void (^ _Nullable)(MTMessage * _Nonnull))notificationTapHandler SWIFT_WARN_UNUSED_RESULT;
+ (void)setNotificationTapHandler:(void (^ _Nullable)(MTMessage * _Nonnull))value;
/// The message handling object defines the behaviour that is triggered during the message handling.
/// You can implement your own message handling either by subclassing <code>MMDefaultMessageHandling</code> or implementing the <code>MessageHandling</code> protocol.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <MessageHandling> _Nonnull messageHandling;)
+ (id <MessageHandling> _Nonnull)messageHandling SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessageHandling:(id <MessageHandling> _Nonnull)value;
/// The <code>URLSessionConfiguration</code> used for all url connections in the SDK
/// Default value is <code>URLSessionConfiguration.default</code>.
/// You can provide your own configuration to define a custom NSURLProtocol, policies etc.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) NSURLSessionConfiguration * _Nonnull urlSessionConfiguration;)
+ (NSURLSessionConfiguration * _Nonnull)urlSessionConfiguration SWIFT_WARN_UNUSED_RESULT;
+ (void)setUrlSessionConfiguration:(NSURLSessionConfiguration * _Nonnull)value;
/// The <code>PrivacySettings</code> class incapsulates privacy settings that affect the SDK behaviour and business logic.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) PrivacySettings * _Nonnull privacySettings;)
+ (PrivacySettings * _Nonnull)privacySettings SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// Fabric method for Mobile Messaging session.
/// App Groups used to share data among app Notification Extension and the main application itself. Provide the appropriate App Group ID for both application and application extension in order to keep them in sync.
/// remark:
/// If you are facing with the following error in your console:
/// <code>[User Defaults] Failed to read values in CFPrefsPlistSource<0xXXXXXXX> (Domain: ..., User: kCFPreferencesAnyUser, ByHost: Yes, Container: (null)): Using kCFPreferencesAnyUser with a container is only allowed for SystemContainers, detaching from cfprefsd</code>.
/// Although this warning doesn’t mean that our code doesn’t work, you can shut it up by prefixing your App Group ID with a Team ID of a certificate that you are signing the build with. For example: <code>"9S95Y6XXXX.group.com.mobile-messaging.notification-service-extension"</code>. The App Group ID itself doesn’t need to be changed though.
/// \param appGroupId An ID of an App Group
///
- (MobileMessaging * _Nonnull)withAppGroupId:(NSString * _Nonnull)appGroupId SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,introduced=10.0);
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// This service manages geofencing areas, emits geografical regions entering/exiting notifications.
/// You access the Geofencing service APIs through this property.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GeofencingService * _Nullable geofencingService;)
+ (GeofencingService * _Nullable)geofencingService SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// Use this method to enable the Geofencing service.
- (MobileMessaging * _Nonnull)withGeofencingService SWIFT_WARN_UNUSED_RESULT;
@end

@protocol NotificationActionHandling;
@class NotificationCategory;

@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// The <code>notificationActionHandler</code> object defines the custom behaviour that is triggered while handling the interactive notifications action.
/// Implement your own notification action hander class by implementing the <code>NotificationActionHandling</code> protocol.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <NotificationActionHandling> _Nullable notificationActionHandler;)
+ (id <NotificationActionHandling> _Nullable)notificationActionHandler SWIFT_WARN_UNUSED_RESULT;
+ (void)setNotificationActionHandler:(id <NotificationActionHandling> _Nullable)value;
/// Fabric method for Mobile Messaging session.
/// remark:
/// Mobile Messaging SDK reserves category Ids and action Ids with “mm_” prefix. Custom actions and categories with this prefix will be discarded.
/// \param categories Set of categories to define which buttons to display and their behavour.
///
- (MobileMessaging * _Nonnull)withInteractiveNotificationCategories:(NSSet<NotificationCategory *> * _Nonnull)categories SWIFT_WARN_UNUSED_RESULT;
/// This method handles interactive notifications actions and performs work that is defined for this action. The method should be called from AppDelegate’s <code>application(_:handleActionWithIdentifier:for:withResponseInfo:completionHandler:)</code> callback.
/// \param identifier The identifier for the interactive notification action.
///
/// \param localNotification The local notification object that was triggered.
///
/// \param responseInfo The data dictionary sent by the action. Potentially could contain text entered by the user in response to the text input action.
///
/// \param completionHandler A block that you must call when you are finished performing the action. It is originally passed to AppDelegate’s <code>application(_:handleActionWithIdentifier:for:withResponseInfo:completionHandler:)</code> callback as a <code>completionHandler</code> parameter.
///
+ (void)handleActionWithIdentifierWithIdentifier:(NSString * _Nullable)identifier localNotification:(UILocalNotification * _Nonnull)localNotification responseInfo:(NSDictionary * _Nullable)responseInfo completionHandler:(void (^ _Nonnull)(void))completionHandler;
/// This method handles interactive notifications actions and performs work that is defined for this action. The method should be called from AppDelegate’s <code>application(_:handleActionWithIdentifier:forRemoteNotification:withResponseInfo:completionHandler:)</code> callback.
/// \param identifier The identifier for the interactive notification action.
///
/// \param userInfo A dictionary that contains information related to the remote notification. This dictionary originates from the provider as a JSON-defined dictionary, which iOS converts to an NSDictionary object before calling this method. The contents of the dictionary are the remote notification payload, which consists only of property-list objects plus NSNull
///
/// \param responseInfo The data dictionary sent by the action. Potentially could contain text entered by the user in response to the text input action.
///
/// \param completionHandler A block that you must call when you are finished performing the action. It is originally passed to AppDelegate’s <code>application(_:handleActionWithIdentifier:forRemoteNotification:withResponseInfo:completionHandler:)</code> callback as a <code>completionHandler</code> parameter.
///
+ (void)handleActionWithIdentifierWithIdentifier:(NSString * _Nullable)identifier forRemoteNotification:(NSDictionary * _Nonnull)userInfo responseInfo:(NSDictionary * _Nullable)responseInfo completionHandler:(void (^ _Nonnull)(void))completionHandler;
/// This method handles interactive notifications actions and performs work that is defined for this action.
/// \param identifier The identifier for the interactive notification action.
///
/// \param message The <code>MTMessage</code> object the action associated with.
///
/// \param responseInfo The data dictionary sent by the action. Potentially could contain text entered by the user in response to the text input action.
///
/// \param completionHandler A block that you must call when you are finished performing the action.
///
+ (void)handleActionWithIdentifierWithIdentifier:(NSString * _Nullable)identifier message:(MTMessage * _Nullable)message responseInfo:(NSDictionary * _Nullable)responseInfo completionHandler:(void (^ _Nonnull)(void))completionHandler;
/// Returns <code>NotificationCategory</code> object for provided category Id. Category Id can be obtained from <code>MTMessage</code> object with <code>MTMessage.category</code> method.
/// \param identifier The identifier associated with the category of interactive notification
///
+ (NotificationCategory * _Nullable)categoryWithId:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
@end

@class UIApplication;

/// The Application Delegate inheritance - is a way to integrate Mobile Messaging SDK into your application.
/// To implement this way, you should inherit your Application Delegate from <code>MobileMessagingAppDelegate</code>.
SWIFT_CLASS("_TtC15MobileMessaging26MobileMessagingAppDelegate")
@interface MobileMessagingAppDelegate : UIResponder <UIApplicationDelegate>
/// Passes your Application Code to the Mobile Messaging SDK.
/// In order to provide your own unique Application Code, you override this variable in your application delegate, that you inherit from <code>MobileMessagingAppDelegate</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull applicationCode;
@property (nonatomic, readonly, copy) NSString * _Nullable appGroupId;
/// Preferable notification types that indicating how the app alerts the user when a push notification arrives.
/// You should override this variable in your application delegate, that you inherit from <code>MobileMessagingAppDelegate</code>.
/// remark:
/// For now, Mobile Messaging SDK doesn’t support badge. You should handle the badge counter by yourself.
@property (nonatomic, readonly, strong) UserNotificationType * _Nonnull userNotificationType;
/// Set of categories that indicating which buttons will be displayed and behavour of these buttons when a push notification arrives.
/// You can override this variable in your application delegate, that you inherit from <code>MobileMessagingAppDelegate</code>.
/// Once application started, provided categories will be registered.
/// remark:
/// Mobile Messaging SDK reserves category Ids and action Ids with “mm_” prefix. Custom actions and categories with this prefix will be discarded.
@property (nonatomic, readonly, copy) NSSet<NotificationCategory *> * _Nullable interactiveNotificationCategories;
- (BOOL)application:(UIApplication * _Nonnull)application didFinishLaunchingWithOptions:(NSDictionary<UIApplicationLaunchOptionsKey, id> * _Nullable)launchOptions SWIFT_WARN_UNUSED_RESULT;
- (void)application:(UIApplication * _Nonnull)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData * _Nonnull)deviceToken;
- (void)application:(UIApplication * _Nonnull)application didReceiveRemoteNotification:(NSDictionary * _Nonnull)userInfo fetchCompletionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))completionHandler;
- (void)application:(UIApplication * _Nonnull)application didReceiveLocalNotification:(UILocalNotification * _Nonnull)notification;
- (void)application:(UIApplication * _Nonnull)application handleActionWithIdentifier:(NSString * _Nullable)identifier forLocalNotification:(UILocalNotification * _Nonnull)notification completionHandler:(void (^ _Nonnull)(void))completionHandler;
- (void)application:(UIApplication * _Nonnull)application handleActionWithIdentifier:(NSString * _Nullable)identifier forRemoteNotification:(NSDictionary * _Nonnull)userInfo completionHandler:(void (^ _Nonnull)(void))completionHandler;
- (void)application:(UIApplication * _Nonnull)application handleActionWithIdentifier:(NSString * _Nullable)identifier forLocalNotification:(UILocalNotification * _Nonnull)notification withResponseInfo:(NSDictionary * _Nonnull)responseInfo completionHandler:(void (^ _Nonnull)(void))completionHandler;
- (void)application:(UIApplication * _Nonnull)application handleActionWithIdentifier:(NSString * _Nullable)identifier forRemoteNotification:(NSDictionary * _Nonnull)userInfo withResponseInfo:(NSDictionary * _Nonnull)responseInfo completionHandler:(void (^ _Nonnull)(void))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UNNotificationRequest;
@class UNNotificationContent;

SWIFT_CLASS("_TtC15MobileMessaging43MobileMessagingNotificationServiceExtension")
@interface MobileMessagingNotificationServiceExtension : NSObject
/// Starts a new Mobile Messaging Notification Service Extension session.
/// This method should be called form <code>didReceive(_:, withContentHandler:)</code> of your subclass of UNNotificationServiceExtension.
/// remark:
/// If you are facing with the following error in your console:
/// <code>[User Defaults] Failed to read values in CFPrefsPlistSource<0xXXXXXXX> (Domain: ..., User: kCFPreferencesAnyUser, ByHost: Yes, Container: (null)): Using kCFPreferencesAnyUser with a container is only allowed for SystemContainers, detaching from cfprefsd</code>.
/// Although this warning doesn’t mean that our code doesn’t work, you can shut it up by prefixing your App Group ID with a Team ID of a certificate that you are signing the build with. For example: <code>"9S95Y6XXXX.group.com.mobile-messaging.notification-service-extension"</code>. The App Group ID itself doesn’t need to be changed though.
/// \param code The application code of your Application from Push Portal website.
///
/// \param appGroupId An ID of an App Group. App Groups used to share data among app Notification Extension and the main application itself. Provide the appropriate App Group ID for both application and application extension in order to keep them in sync.
///
+ (void)startWithApplicationCode:(NSString * _Nonnull)code appGroupId:(NSString * _Nonnull)appGroupId;
/// This method handles an incoming notification on the Notification Service Extensions side. It performs message delivery reporting and downloads data from <code>contentUrl</code> if provided. This method must be called within <code>UNNotificationServiceExtension.didReceive(_: withContentHandler:)</code> callback.
/// \param request The original notification request. Use this object to get the original content of the notification.
///
/// \param contentHandler The block to execute with the modified content. The block will be called after the delivery reporting and contend downloading finished.
///
+ (void)didReceive:(UNNotificationRequest * _Nonnull)request withContentHandler:(void (^ _Nonnull)(UNNotificationContent * _Nonnull))contentHandler;
+ (void)serviceExtensionTimeWillExpire;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging23UserDataFoundationTypes_")
@protocol UserDataFoundationTypes
@end


@interface NSDate (SWIFT_EXTENSION(MobileMessaging)) <UserDataFoundationTypes>
@end




@interface NSError (SWIFT_EXTENSION(MobileMessaging))
@property (nonatomic, readonly, copy) NSString * _Nullable mm_message;
@property (nonatomic, readonly, copy) NSString * _Nullable mm_code;
@end








@interface NSNull (SWIFT_EXTENSION(MobileMessaging)) <UserDataFoundationTypes>
@end


@interface NSNull (SWIFT_EXTENSION(MobileMessaging)) <CustomPayloadSupportedTypes>
@end


@interface NSNumber (SWIFT_EXTENSION(MobileMessaging)) <UserDataFoundationTypes>
@end


@interface NSNumber (SWIFT_EXTENSION(MobileMessaging)) <CustomPayloadSupportedTypes>
@end








@interface NSString (SWIFT_EXTENSION(MobileMessaging)) <CustomPayloadSupportedTypes>
@end


@interface NSString (SWIFT_EXTENSION(MobileMessaging)) <UserDataFoundationTypes>
@end

@class NotificationActionOptions;

SWIFT_CLASS("_TtC15MobileMessaging18NotificationAction")
@interface NotificationAction : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
@property (nonatomic, readonly, copy) NSArray<NotificationActionOptions *> * _Nonnull options;
/// Initializes the <code>NotificationAction</code>
/// \param identifier action identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param title Title of the button which will be displayed.
///
/// \param options Options with which to perform the action.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier title:(NSString * _Nonnull)title options:(NSArray<NotificationActionOptions *> * _Nullable)options;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging26NotificationActionHandling_")
@protocol NotificationActionHandling
/// This method will be triggered during the notification action handling.
/// \param action <code>NotificationAction</code> object defining the action which was triggered.
///
/// \param message <code>MTMessage</code> message, for which action button was displayed, you can use <code>message.categoryId</code> in order to check the categoryId for action.
///
/// \param completionHandler The block to execute when specified action performing is finished. You must call this block once the work is completed. The block is originally passed to AppDelegate’s <code>application(_:handleActionWithIdentifier:forRemoteNotification:completionHandler:)</code> callback as a <code>completionHandler</code> parameter.
///
- (void)handleWithAction:(NotificationAction * _Nonnull)action forMessage:(MTMessage * _Nonnull)message withCompletionHandler:(void (^ _Nonnull)(void))completionHandler;
@end


SWIFT_CLASS("_TtC15MobileMessaging25NotificationActionOptions")
@interface NotificationActionOptions : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<NotificationActionOptions *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMLogOutput * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
/// Causes the launch of the application.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull foreground;)
+ (NotificationActionOptions * _Nonnull)foreground SWIFT_WARN_UNUSED_RESULT;
/// Marks the action button as destructive.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull destructive;)
+ (NotificationActionOptions * _Nonnull)destructive SWIFT_WARN_UNUSED_RESULT;
/// Requires the device to be unlocked.
/// remark:
/// If the action options contains <code>.foreground</code>, then the action is considered as requiring authentication automatically.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull authenticationRequired;)
+ (NotificationActionOptions * _Nonnull)authenticationRequired SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether the SDK must generate MO message to report on users interaction.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationActionOptions * _Nonnull moRequired;)
+ (NotificationActionOptions * _Nonnull)moRequired SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

@class NotificationCategoryOptions;

SWIFT_CLASS("_TtC15MobileMessaging20NotificationCategory")
@interface NotificationCategory : NSObject
/// The category identifier passed in a <code>MTMessage</code> object
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// Actions in the order to be displayed for available contexts.
/// remark:
/// If there are more than four action objects in the array, the notification displays only the first four. When displaying banner notifications, the system displays only the first two actions.
@property (nonatomic, readonly, copy) NSArray<NotificationAction *> * _Nonnull actions;
/// Options indicating how to handle notifications associated with category.
@property (nonatomic, readonly, copy) NSArray<NotificationCategoryOptions *> * _Nonnull options;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull intentIdentifiers;
/// Initializes the <code>NotificationCategory</code>
/// \param identifier category identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param actions Actions in the order to be displayed for available contexts.
///
/// \param options Options indicating how to handle notifications associated with category. Supported only for iOS 10+.
///
/// \param intentIdentifiers The intent identifier strings, which defined in Intents framework, that you want to associate with notifications of this category. Supported only for iOS 10+.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier actions:(NSArray<NotificationAction *> * _Nonnull)actions options:(NSArray<NotificationCategoryOptions *> * _Nullable)options intentIdentifiers:(NSArray<NSString *> * _Nullable)intentIdentifiers OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging27NotificationCategoryOptions")
@interface NotificationCategoryOptions : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<NotificationCategoryOptions *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(NotificationCategoryOptions * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
/// remark:
/// This option is available only for iOS 10+
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationCategoryOptions * _Nonnull customDismissAction;)
+ (NotificationCategoryOptions * _Nonnull)customDismissAction SWIFT_WARN_UNUSED_RESULT;
/// remark:
/// This option is available only for iOS 10+
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NotificationCategoryOptions * _Nonnull allowInCarPlay;)
+ (NotificationCategoryOptions * _Nonnull)allowInCarPlay SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end







/// <code>OperationQueue</code> is an <code>NSOperationQueue</code> subclass that implements a large
/// number of “extra features” related to the <code>Operation</code> class:
/// <ul>
///   <li>
///     Notifying a delegate of all operation completion
///   </li>
///   <li>
///     Extracting generated dependencies from operation conditions
///   </li>
///   <li>
///     Setting up dependencies to enforce mutual exclusivity
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15MobileMessaging14OperationQueue")
@interface OperationQueue : NSOperationQueue
@property (nonatomic, weak) id <OperationQueueDelegate> _Nullable delegate;
- (void)addOperation:(NSOperation * _Nonnull)operation;
- (void)addOperations:(NSArray<NSOperation *> * _Nonnull)ops waitUntilFinished:(BOOL)wait;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// The <code>PrivacySettings</code> class incapsulates privacy settings that affect the SDK behaviour and business logic.
SWIFT_CLASS("_TtC15MobileMessaging15PrivacySettings")
@interface PrivacySettings : NSObject
/// A boolean variable that indicates whether the MobileMessaging SDK will be sending the carrier information to the server.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL carrierInfoSendingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be sending the system information such as OS version, device model, application version to the server.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL systemInfoSendingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be persisting the application code locally. This feature is a convenience to maintain SDK viability during debugging and possible application code changes.
/// Default value is <code>false</code>.
/// warning:
/// there might be situation when you want to switch between different Application Codes during development/testing. If you disable the application code persisting (value <code>true</code>), the SDK won’t detect the application code changes, thus won’t cleanup the old application code related data. You should manually invoke <code>MobileMessaging.cleanUpAndStop()</code> prior to start otherwise the SDK would not detect the application code change.
@property (nonatomic) BOOL applicationCodePersistingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be persisting the user data locally. Persisting user data locally gives you quick access to the data and eliminates a need to implement it yourself.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL userDataPersistingDisabled;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSPredicate;
@class NSSortDescriptor;

/// The class defines a query that is used to fetch messages from the Message Storage.
SWIFT_CLASS("_TtC15MobileMessaging5Query")
@interface Query : NSObject
/// The following types of predicates are supported:
/// <ul>
///   <li>
///     Simple comparisons such as <code>=</code>, <code>!=</code>, <code><</code>, <code>></code>, <code><=</code>, <code>>=</code>, and <code>BETWEEN</code> with a key and a constant.
///   </li>
///   <li>
///     Containment predicates, such as <code>x IN {1, 2, 3}</code>.
///   </li>
///   <li>
///     Key-existence predicates, such as <code>x IN SELF</code>.
///   </li>
///   <li>
///     BEGINSWITH expressions.
///   </li>
///   <li>
///     Compound predicates with <code>AND</code>, <code>OR</code>, and <code>NOT</code>.
///   </li>
///   <li>
///     SubQueries with <code>key IN %@</code>, subquery.
///   </li>
/// </ul>
/// The following types of predicates are NOT supported:
/// <ul>
///   <li>
///     Aggregate operations, such as <code>ANY</code>, <code>SOME</code>, <code>ALL</code>, or <code>NONE</code>.
///   </li>
///   <li>
///     Regular expressions, such as <code>LIKE</code>, <code>MATCHES</code>, <code>CONTAINS</code>, or <code>ENDSWITH</code>.
///   </li>
///   <li>
///     Predicates comparing one key to another.
///   </li>
///   <li>
///     Complex predicates with many ORed clauses.
///   </li>
/// </ul>
@property (nonatomic, strong) NSPredicate * _Nullable predicate;
/// An array of <code>NSSortDescriptor</code> objects to use to sort the results of the query.
@property (nonatomic, copy) NSArray<NSSortDescriptor *> * _Nullable sortDescriptors;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


/// Allows text input from the user
SWIFT_CLASS("_TtC15MobileMessaging27TextInputNotificationAction")
@interface TextInputNotificationAction : NotificationAction
@property (nonatomic, readonly, copy) NSString * _Nonnull textInputActionButtonTitle;
@property (nonatomic, readonly, copy) NSString * _Nonnull textInputPlaceholder;
/// Text which was entered in response to action.
@property (nonatomic, copy) NSString * _Nullable typedText;
/// Initializes the <code>TextInputNotificationAction</code>
/// \param identifier action identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param title Title of the button which will be displayed.
///
/// \param options Options with which to perform the action.
///
/// \param textInputActionButtonTitle Title of the text input action button
///
/// \param textInputPlaceholder Placeholder in the text input field.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier title:(NSString * _Nonnull)title options:(NSArray<NotificationActionOptions *> * _Nullable)options textInputActionButtonTitle:(NSString * _Nonnull)textInputActionButtonTitle textInputPlaceholder:(NSString * _Nonnull)textInputPlaceholder OBJC_DESIGNATED_INITIALIZER;
@end




@interface UIDevice (SWIFT_EXTENSION(MobileMessaging))
- (BOOL)SYSTEM_VERSION_LESS_THAN:(NSString * _Nonnull)version SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) BOOL IS_IOS_BEFORE_10;
@end






SWIFT_CLASS("_TtC15MobileMessaging9UserAgent")
@interface UserAgent : NSObject
@property (nonatomic, copy) NSString * _Nullable cordovaPluginVersion;
@property (nonatomic, readonly) BOOL notificationsEnabled;
@property (nonatomic, readonly, copy) NSString * _Nonnull currentUserAgentString;
@property (nonatomic, readonly, copy) NSString * _Nonnull osVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull osName;
@property (nonatomic, readonly, copy) NSString * _Nonnull libraryVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull libraryName;
@property (nonatomic, readonly, copy) NSString * _Nonnull hostingAppVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull hostingAppName;
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceManufacturer;
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceName;
@property (nonatomic, readonly) BOOL deviceSecure;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



SWIFT_CLASS("_TtC15MobileMessaging20UserNotificationType")
@interface UserNotificationType : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<UserNotificationType *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(UserNotificationType * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull none;)
+ (UserNotificationType * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
/// The ability to display alerts.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull alert;)
+ (UserNotificationType * _Nonnull)alert SWIFT_WARN_UNUSED_RESULT;
/// The ability to update the app’s badge.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull badge;)
+ (UserNotificationType * _Nonnull)badge SWIFT_WARN_UNUSED_RESULT;
/// The ability to play sounds.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull sound;)
+ (UserNotificationType * _Nonnull)sound SWIFT_WARN_UNUSED_RESULT;
/// The ability to display notifications in a CarPlay environment.
/// remark:
/// This option is available only for iOS 10+
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) UserNotificationType * _Nonnull carPlay;)
+ (UserNotificationType * _Nonnull)carPlay SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end

SWIFT_MODULE_NAMESPACE_POP
#pragma clang diagnostic pop
